<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1"><style>@font-face {
  font-family: octicons-link;
  src: url(data:font/woff;charset=utf-8;base64,d09GRgABAAAAAAZwABAAAAAACFQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABEU0lHAAAGaAAAAAgAAAAIAAAAAUdTVUIAAAZcAAAACgAAAAoAAQAAT1MvMgAAAyQAAABJAAAAYFYEU3RjbWFwAAADcAAAAEUAAACAAJThvmN2dCAAAATkAAAABAAAAAQAAAAAZnBnbQAAA7gAAACyAAABCUM+8IhnYXNwAAAGTAAAABAAAAAQABoAI2dseWYAAAFsAAABPAAAAZwcEq9taGVhZAAAAsgAAAA0AAAANgh4a91oaGVhAAADCAAAABoAAAAkCA8DRGhtdHgAAAL8AAAADAAAAAwGAACfbG9jYQAAAsAAAAAIAAAACABiATBtYXhwAAACqAAAABgAAAAgAA8ASm5hbWUAAAToAAABQgAAAlXu73sOcG9zdAAABiwAAAAeAAAAME3QpOBwcmVwAAAEbAAAAHYAAAB/aFGpk3jaTY6xa8JAGMW/O62BDi0tJLYQincXEypYIiGJjSgHniQ6umTsUEyLm5BV6NDBP8Tpts6F0v+k/0an2i+itHDw3v2+9+DBKTzsJNnWJNTgHEy4BgG3EMI9DCEDOGEXzDADU5hBKMIgNPZqoD3SilVaXZCER3/I7AtxEJLtzzuZfI+VVkprxTlXShWKb3TBecG11rwoNlmmn1P2WYcJczl32etSpKnziC7lQyWe1smVPy/Lt7Kc+0vWY/gAgIIEqAN9we0pwKXreiMasxvabDQMM4riO+qxM2ogwDGOZTXxwxDiycQIcoYFBLj5K3EIaSctAq2kTYiw+ymhce7vwM9jSqO8JyVd5RH9gyTt2+J/yUmYlIR0s04n6+7Vm1ozezUeLEaUjhaDSuXHwVRgvLJn1tQ7xiuVv/ocTRF42mNgZGBgYGbwZOBiAAFGJBIMAAizAFoAAABiAGIAznjaY2BkYGAA4in8zwXi+W2+MjCzMIDApSwvXzC97Z4Ig8N/BxYGZgcgl52BCSQKAA3jCV8CAABfAAAAAAQAAEB42mNgZGBg4f3vACQZQABIMjKgAmYAKEgBXgAAeNpjYGY6wTiBgZWBg2kmUxoDA4MPhGZMYzBi1AHygVLYQUCaawqDA4PChxhmh/8ODDEsvAwHgMKMIDnGL0x7gJQCAwMAJd4MFwAAAHjaY2BgYGaA4DAGRgYQkAHyGMF8NgYrIM3JIAGVYYDT+AEjAwuDFpBmA9KMDEwMCh9i/v8H8sH0/4dQc1iAmAkALaUKLgAAAHjaTY9LDsIgEIbtgqHUPpDi3gPoBVyRTmTddOmqTXThEXqrob2gQ1FjwpDvfwCBdmdXC5AVKFu3e5MfNFJ29KTQT48Ob9/lqYwOGZxeUelN2U2R6+cArgtCJpauW7UQBqnFkUsjAY/kOU1cP+DAgvxwn1chZDwUbd6CFimGXwzwF6tPbFIcjEl+vvmM/byA48e6tWrKArm4ZJlCbdsrxksL1AwWn/yBSJKpYbq8AXaaTb8AAHja28jAwOC00ZrBeQNDQOWO//sdBBgYGRiYWYAEELEwMTE4uzo5Zzo5b2BxdnFOcALxNjA6b2ByTswC8jYwg0VlNuoCTWAMqNzMzsoK1rEhNqByEyerg5PMJlYuVueETKcd/89uBpnpvIEVomeHLoMsAAe1Id4AAAAAAAB42oWQT07CQBTGv0JBhagk7HQzKxca2sJCE1hDt4QF+9JOS0nbaaYDCQfwCJ7Au3AHj+LO13FMmm6cl7785vven0kBjHCBhfpYuNa5Ph1c0e2Xu3jEvWG7UdPDLZ4N92nOm+EBXuAbHmIMSRMs+4aUEd4Nd3CHD8NdvOLTsA2GL8M9PODbcL+hD7C1xoaHeLJSEao0FEW14ckxC+TU8TxvsY6X0eLPmRhry2WVioLpkrbp84LLQPGI7c6sOiUzpWIWS5GzlSgUzzLBSikOPFTOXqly7rqx0Z1Q5BAIoZBSFihQYQOOBEdkCOgXTOHA07HAGjGWiIjaPZNW13/+lm6S9FT7rLHFJ6fQbkATOG1j2OFMucKJJsxIVfQORl+9Jyda6Sl1dUYhSCm1dyClfoeDve4qMYdLEbfqHf3O/AdDumsjAAB42mNgYoAAZQYjBmyAGYQZmdhL8zLdDEydARfoAqIAAAABAAMABwAKABMAB///AA8AAQAAAAAAAAAAAAAAAAABAAAAAA==) format('woff');
}

body {
    width: 980px;
    margin-right: auto;
    margin-left: auto;
    color:#333;
    background:#fff;
}

body .markdown-body {
    padding: 45px;
    word-wrap: break-word;
}

.markdown-body .octicon-link:before {
  font: normal normal normal 16px/1 octicons-link;
  display: inline-block;
  text-decoration: none;
  text-rendering: auto;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
  -webkit-user-select: none;
  -moz-user-select: none;
  -ms-user-select: none;
  user-select: none;
  content: '\f05c';
  vertical-align: middle;
}

.markdown-body .anchor {
  float: left;
  line-height: 1;
  margin-left: -20px;
  padding-right: 4px;
}

.markdown-body .anchor:focus {
  outline: none;
}

.markdown-body h1 .octicon-link,
.markdown-body h2 .octicon-link,
.markdown-body h3 .octicon-link,
.markdown-body h4 .octicon-link,
.markdown-body h5 .octicon-link,
.markdown-body h6 .octicon-link {
  color: #1b1f23;
  vertical-align: middle;
  visibility: hidden;
}

.markdown-body h1:hover .anchor,
.markdown-body h2:hover .anchor,
.markdown-body h3:hover .anchor,
.markdown-body h4:hover .anchor,
.markdown-body h5:hover .anchor,
.markdown-body h6:hover .anchor {
  text-decoration: none;
}

.markdown-body h1:hover .anchor .octicon-link,
.markdown-body h2:hover .anchor .octicon-link,
.markdown-body h3:hover .anchor .octicon-link,
.markdown-body h4:hover .anchor .octicon-link,
.markdown-body h5:hover .anchor .octicon-link,
.markdown-body h6:hover .anchor .octicon-link {
  visibility: visible;
}

.markdown-body {
  -ms-text-size-adjust: 100%;
  -webkit-text-size-adjust: 100%;
  color: #24292e;
  line-height: 1.5;
  font-family: -apple-system,BlinkMacSystemFont,Segoe UI,Helvetica,Arial,sans-serif,Apple Color Emoji,Segoe UI Emoji,Segoe UI Symbol;
  font-size: 16px;
  line-height: 1.5;
  word-wrap: break-word;
}

.markdown-body .pl-c {
  color: #6a737d;
}

.markdown-body .pl-c1,
.markdown-body .pl-s .pl-v {
  color: #005cc5;
}

.markdown-body .pl-e,
.markdown-body .pl-en {
  color: #6f42c1;
}

.markdown-body .pl-s .pl-s1,
.markdown-body .pl-smi {
  color: #24292e;
}

.markdown-body .pl-ent {
  color: #22863a;
}

.markdown-body .pl-k {
  color: #d73a49;
}

.markdown-body .pl-pds,
.markdown-body .pl-s,
.markdown-body .pl-s .pl-pse .pl-s1,
.markdown-body .pl-sr,
.markdown-body .pl-sr .pl-cce,
.markdown-body .pl-sr .pl-sra,
.markdown-body .pl-sr .pl-sre {
  color: #032f62;
}

.markdown-body .pl-smw,
.markdown-body .pl-v {
  color: #e36209;
}

.markdown-body .pl-bu {
  color: #b31d28;
}

.markdown-body .pl-ii {
  background-color: #b31d28;
  color: #fafbfc;
}

.markdown-body .pl-c2 {
  background-color: #d73a49;
  color: #fafbfc;
}

.markdown-body .pl-c2:before {
  content: "^M";
}

.markdown-body .pl-sr .pl-cce {
  color: #22863a;
  font-weight: 700;
}

.markdown-body .pl-ml {
  color: #735c0f;
}

.markdown-body .pl-mh,
.markdown-body .pl-mh .pl-en,
.markdown-body .pl-ms {
  color: #005cc5;
  font-weight: 700;
}

.markdown-body .pl-mi {
  color: #24292e;
  font-style: italic;
}

.markdown-body .pl-mb {
  color: #24292e;
  font-weight: 700;
}

.markdown-body .pl-md {
  background-color: #ffeef0;
  color: #b31d28;
}

.markdown-body .pl-mi1 {
  background-color: #f0fff4;
  color: #22863a;
}

.markdown-body .pl-mc {
  background-color: #ffebda;
  color: #e36209;
}

.markdown-body .pl-mi2 {
  background-color: #005cc5;
  color: #f6f8fa;
}

.markdown-body .pl-mdr {
  color: #6f42c1;
  font-weight: 700;
}

.markdown-body .pl-ba {
  color: #586069;
}

.markdown-body .pl-sg {
  color: #959da5;
}

.markdown-body .pl-corl {
  color: #032f62;
  text-decoration: underline;
}

.markdown-body details {
  display: block;
}

.markdown-body summary {
  display: list-item;
}

.markdown-body a {
  background-color: transparent;
}

.markdown-body a:active,
.markdown-body a:hover {
  outline-width: 0;
}

.markdown-body strong {
  font-weight: inherit;
  font-weight: bolder;
}

.markdown-body h1 {
  font-size: 2em;
  margin: .67em 0;
}

.markdown-body img {
  border-style: none;
}

.markdown-body code,
.markdown-body kbd,
.markdown-body pre {
  font-family: monospace,monospace;
  font-size: 1em;
}

.markdown-body hr {
  box-sizing: content-box;
  height: 0;
  overflow: visible;
}

.markdown-body input {
  font: inherit;
  margin: 0;
}

.markdown-body input {
  overflow: visible;
}

.markdown-body [type=checkbox] {
  box-sizing: border-box;
  padding: 0;
}

.markdown-body * {
  box-sizing: border-box;
}

.markdown-body input {
  font-family: inherit;
  font-size: inherit;
  line-height: inherit;
}

.markdown-body a {
  color: #0366d6;
  text-decoration: none;
}

.markdown-body a:hover {
  text-decoration: underline;
}

.markdown-body strong {
  font-weight: 600;
}

.markdown-body hr {
  background: transparent;
  border: 0;
  border-bottom: 1px solid #dfe2e5;
  height: 0;
  margin: 15px 0;
  overflow: hidden;
}

.markdown-body hr:before {
  content: "";
  display: table;
}

.markdown-body hr:after {
  clear: both;
  content: "";
  display: table;
}

.markdown-body table {
  border-collapse: collapse;
  border-spacing: 0;
}

.markdown-body td,
.markdown-body th {
  padding: 0;
}

.markdown-body details summary {
  cursor: pointer;
}

.markdown-body h1,
.markdown-body h2,
.markdown-body h3,
.markdown-body h4,
.markdown-body h5,
.markdown-body h6 {
  margin-bottom: 0;
  margin-top: 0;
}

.markdown-body h1 {
  font-size: 32px;
}

.markdown-body h1,
.markdown-body h2 {
  font-weight: 600;
}

.markdown-body h2 {
  font-size: 24px;
}

.markdown-body h3 {
  font-size: 20px;
}

.markdown-body h3,
.markdown-body h4 {
  font-weight: 600;
}

.markdown-body h4 {
  font-size: 16px;
}

.markdown-body h5 {
  font-size: 14px;
}

.markdown-body h5,
.markdown-body h6 {
  font-weight: 600;
}

.markdown-body h6 {
  font-size: 12px;
}

.markdown-body p {
  margin-bottom: 10px;
  margin-top: 0;
}

.markdown-body blockquote {
  margin: 0;
}

.markdown-body ol,
.markdown-body ul {
  margin-bottom: 0;
  margin-top: 0;
  padding-left: 0;
}

.markdown-body ol ol,
.markdown-body ul ol {
  list-style-type: lower-roman;
}

.markdown-body ol ol ol,
.markdown-body ol ul ol,
.markdown-body ul ol ol,
.markdown-body ul ul ol {
  list-style-type: lower-alpha;
}

.markdown-body dd {
  margin-left: 0;
}

.markdown-body code,
.markdown-body pre {
  font-family: SFMono-Regular,Consolas,Liberation Mono,Menlo,Courier,monospace;
  font-size: 12px;
}

.markdown-body pre {
  margin-bottom: 0;
  margin-top: 0;
}

.markdown-body input::-webkit-inner-spin-button,
.markdown-body input::-webkit-outer-spin-button {
  -webkit-appearance: none;
  appearance: none;
  margin: 0;
}

.markdown-body .border {
  border: 1px solid #e1e4e8!important;
}

.markdown-body .border-0 {
  border: 0!important;
}

.markdown-body .border-bottom {
  border-bottom: 1px solid #e1e4e8!important;
}

.markdown-body .rounded-1 {
  border-radius: 3px!important;
}

.markdown-body .bg-white {
  background-color: #fff!important;
}

.markdown-body .bg-gray-light {
  background-color: #fafbfc!important;
}

.markdown-body .text-gray-light {
  color: #6a737d!important;
}

.markdown-body .mb-0 {
  margin-bottom: 0!important;
}

.markdown-body .my-2 {
  margin-bottom: 8px!important;
  margin-top: 8px!important;
}

.markdown-body .pl-0 {
  padding-left: 0!important;
}

.markdown-body .py-0 {
  padding-bottom: 0!important;
  padding-top: 0!important;
}

.markdown-body .pl-1 {
  padding-left: 4px!important;
}

.markdown-body .pl-2 {
  padding-left: 8px!important;
}

.markdown-body .py-2 {
  padding-bottom: 8px!important;
  padding-top: 8px!important;
}

.markdown-body .pl-3,
.markdown-body .px-3 {
  padding-left: 16px!important;
}

.markdown-body .px-3 {
  padding-right: 16px!important;
}

.markdown-body .pl-4 {
  padding-left: 24px!important;
}

.markdown-body .pl-5 {
  padding-left: 32px!important;
}

.markdown-body .pl-6 {
  padding-left: 40px!important;
}

.markdown-body .f6 {
  font-size: 12px!important;
}

.markdown-body .lh-condensed {
  line-height: 1.25!important;
}

.markdown-body .text-bold {
  font-weight: 600!important;
}

.markdown-body:before {
  content: "";
  display: table;
}

.markdown-body:after {
  clear: both;
  content: "";
  display: table;
}

.markdown-body>:first-child {
  margin-top: 0!important;
}

.markdown-body>:last-child {
  margin-bottom: 0!important;
}

.markdown-body a:not([href]) {
  color: inherit;
  text-decoration: none;
}

.markdown-body blockquote,
.markdown-body dl,
.markdown-body ol,
.markdown-body p,
.markdown-body pre,
.markdown-body table,
.markdown-body ul {
  margin-bottom: 16px;
  margin-top: 0;
}

.markdown-body hr {
  background-color: #e1e4e8;
  border: 0;
  height: .25em;
  margin: 24px 0;
  padding: 0;
}

.markdown-body blockquote {
  border-left: .25em solid #dfe2e5;
  color: #6a737d;
  padding: 0 1em;
}

.markdown-body blockquote>:first-child {
  margin-top: 0;
}

.markdown-body blockquote>:last-child {
  margin-bottom: 0;
}

.markdown-body kbd {
  background-color: #fafbfc;
  border: 1px solid #c6cbd1;
  border-bottom-color: #959da5;
  border-radius: 3px;
  box-shadow: inset 0 -1px 0 #959da5;
  color: #444d56;
  display: inline-block;
  font-size: 11px;
  line-height: 10px;
  padding: 3px 5px;
  vertical-align: middle;
}

.markdown-body h1,
.markdown-body h2,
.markdown-body h3,
.markdown-body h4,
.markdown-body h5,
.markdown-body h6 {
  font-weight: 600;
  line-height: 1.25;
  margin-bottom: 16px;
  margin-top: 24px;
}

.markdown-body h1 {
  font-size: 2em;
}

.markdown-body h1,
.markdown-body h2 {
  border-bottom: 1px solid #eaecef;
  padding-bottom: .3em;
}

.markdown-body h2 {
  font-size: 1.5em;
}

.markdown-body h3 {
  font-size: 1.25em;
}

.markdown-body h4 {
  font-size: 1em;
}

.markdown-body h5 {
  font-size: .875em;
}

.markdown-body h6 {
  color: #6a737d;
  font-size: .85em;
}

.markdown-body ol,
.markdown-body ul {
  padding-left: 2em;
}

.markdown-body ol ol,
.markdown-body ol ul,
.markdown-body ul ol,
.markdown-body ul ul {
  margin-bottom: 0;
  margin-top: 0;
}

.markdown-body li {
  word-wrap: break-all;
}

.markdown-body li>p {
  margin-top: 16px;
}

.markdown-body li+li {
  margin-top: .25em;
}

.markdown-body dl {
  padding: 0;
}

.markdown-body dl dt {
  font-size: 1em;
  font-style: italic;
  font-weight: 600;
  margin-top: 16px;
  padding: 0;
}

.markdown-body dl dd {
  margin-bottom: 16px;
  padding: 0 16px;
}

.markdown-body table {
  display: block;
  overflow: auto;
  width: 100%;
}

.markdown-body table th {
  font-weight: 600;
}

.markdown-body table td,
.markdown-body table th {
  border: 1px solid #dfe2e5;
  padding: 6px 13px;
}

.markdown-body table tr {
  background-color: #fff;
  border-top: 1px solid #c6cbd1;
}

.markdown-body table tr:nth-child(2n) {
  background-color: #f6f8fa;
}

.markdown-body img {
  background-color: #fff;
  box-sizing: content-box;
  max-width: 100%;
}

.markdown-body img[align=right] {
  padding-left: 20px;
}

.markdown-body img[align=left] {
  padding-right: 20px;
}

.markdown-body code {
  background-color: rgba(27,31,35,.05);
  border-radius: 3px;
  font-size: 85%;
  margin: 0;
  padding: .2em .4em;
}

.markdown-body pre {
  word-wrap: normal;
}

.markdown-body pre>code {
  background: transparent;
  border: 0;
  font-size: 100%;
  margin: 0;
  padding: 0;
  white-space: pre;
  word-break: normal;
}

.markdown-body .highlight {
  margin-bottom: 16px;
}

.markdown-body .highlight pre {
  margin-bottom: 0;
  word-break: normal;
}

.markdown-body .highlight pre,
.markdown-body pre {
  background-color: #f6f8fa;
  border-radius: 3px;
  font-size: 85%;
  line-height: 1.45;
  overflow: auto;
  padding: 16px;
}

.markdown-body pre code {
  background-color: transparent;
  border: 0;
  display: inline;
  line-height: inherit;
  margin: 0;
  max-width: auto;
  overflow: visible;
  padding: 0;
  word-wrap: normal;
}

.markdown-body .commit-tease-sha {
  color: #444d56;
  display: inline-block;
  font-family: SFMono-Regular,Consolas,Liberation Mono,Menlo,Courier,monospace;
  font-size: 90%;
}

.markdown-body .blob-wrapper {
  border-bottom-left-radius: 3px;
  border-bottom-right-radius: 3px;
  overflow-x: auto;
  overflow-y: hidden;
}

.markdown-body .blob-wrapper-embedded {
  max-height: 240px;
  overflow-y: auto;
}

.markdown-body .blob-num {
  -moz-user-select: none;
  -ms-user-select: none;
  -webkit-user-select: none;
  color: rgba(27,31,35,.3);
  cursor: pointer;
  font-family: SFMono-Regular,Consolas,Liberation Mono,Menlo,Courier,monospace;
  font-size: 12px;
  line-height: 20px;
  min-width: 50px;
  padding-left: 10px;
  padding-right: 10px;
  text-align: right;
  user-select: none;
  vertical-align: top;
  white-space: nowrap;
  width: 1%;
}

.markdown-body .blob-num:hover {
  color: rgba(27,31,35,.6);
}

.markdown-body .blob-num:before {
  content: attr(data-line-number);
}

.markdown-body .blob-code {
  line-height: 20px;
  padding-left: 10px;
  padding-right: 10px;
  position: relative;
  vertical-align: top;
}

.markdown-body .blob-code-inner {
  color: #24292e;
  font-family: SFMono-Regular,Consolas,Liberation Mono,Menlo,Courier,monospace;
  font-size: 12px;
  overflow: visible;
  white-space: pre;
  word-wrap: normal;
}

.markdown-body .pl-token.active,
.markdown-body .pl-token:hover {
  background: #ffea7f;
  cursor: pointer;
}

.markdown-body kbd {
  background-color: #fafbfc;
  border: 1px solid #d1d5da;
  border-bottom-color: #c6cbd1;
  border-radius: 3px;
  box-shadow: inset 0 -1px 0 #c6cbd1;
  color: #444d56;
  display: inline-block;
  font: 11px SFMono-Regular,Consolas,Liberation Mono,Menlo,Courier,monospace;
  line-height: 10px;
  padding: 3px 5px;
  vertical-align: middle;
}

.markdown-body :checked+.radio-label {
  border-color: #0366d6;
  position: relative;
  z-index: 1;
}

.markdown-body .tab-size[data-tab-size="1"] {
  -moz-tab-size: 1;
  tab-size: 1;
}

.markdown-body .tab-size[data-tab-size="2"] {
  -moz-tab-size: 2;
  tab-size: 2;
}

.markdown-body .tab-size[data-tab-size="3"] {
  -moz-tab-size: 3;
  tab-size: 3;
}

.markdown-body .tab-size[data-tab-size="4"] {
  -moz-tab-size: 4;
  tab-size: 4;
}

.markdown-body .tab-size[data-tab-size="5"] {
  -moz-tab-size: 5;
  tab-size: 5;
}

.markdown-body .tab-size[data-tab-size="6"] {
  -moz-tab-size: 6;
  tab-size: 6;
}

.markdown-body .tab-size[data-tab-size="7"] {
  -moz-tab-size: 7;
  tab-size: 7;
}

.markdown-body .tab-size[data-tab-size="8"] {
  -moz-tab-size: 8;
  tab-size: 8;
}

.markdown-body .tab-size[data-tab-size="9"] {
  -moz-tab-size: 9;
  tab-size: 9;
}

.markdown-body .tab-size[data-tab-size="10"] {
  -moz-tab-size: 10;
  tab-size: 10;
}

.markdown-body .tab-size[data-tab-size="11"] {
  -moz-tab-size: 11;
  tab-size: 11;
}

.markdown-body .tab-size[data-tab-size="12"] {
  -moz-tab-size: 12;
  tab-size: 12;
}

.markdown-body .task-list-item {
  list-style-type: none;
}

.markdown-body .task-list-item+.task-list-item {
  margin-top: 3px;
}

.markdown-body .task-list-item input {
  margin: 0 .2em .25em -1.6em;
  vertical-align: middle;
}

.markdown-body hr {
  border-bottom-color: #eee;
}

.markdown-body .pl-0 {
  padding-left: 0!important;
}

.markdown-body .pl-1 {
  padding-left: 4px!important;
}

.markdown-body .pl-2 {
  padding-left: 8px!important;
}

.markdown-body .pl-3 {
  padding-left: 16px!important;
}

.markdown-body .pl-4 {
  padding-left: 24px!important;
}

.markdown-body .pl-5 {
  padding-left: 32px!important;
}

.markdown-body .pl-6 {
  padding-left: 40px!important;
}

.markdown-body .pl-7 {
  padding-left: 48px!important;
}

.markdown-body .pl-8 {
  padding-left: 64px!important;
}

.markdown-body .pl-9 {
  padding-left: 80px!important;
}

.markdown-body .pl-10 {
  padding-left: 96px!important;
}

.markdown-body .pl-11 {
  padding-left: 112px!important;
}

.markdown-body .pl-12 {
  padding-left: 128px!important;
}
</style><title>README</title></head><body><article class="markdown-body"><h1>
<a id="user-content-faster-constant-time-decoder-for-mdpc-codes-and-applications-to-bike-kem" class="anchor" href="#faster-constant-time-decoder-for-mdpc-codes-and-applications-to-bike-kem" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Faster constant-time decoder for MDPC codes and applications to BIKE KEM</h1>
<p><strong>Authors</strong>: Thales Paiva and Routo Terada</p>
<p><strong>Table of Contents</strong></p>

<ul>
<li>Abstract</li>
<li>What is included in this repository</li>
<li>BIKE code - Compiling and Running
<ul>
<li>Compilation Flags</li>
<li>The need for <code>make clean</code> when parameters change</li>
<li>Example</li>
</ul>
</li>
<li>Reproducibility
<ul>
<li>Counters
<ul>
<li>Data to be reproduced</li>
<li>Steps to reproduce</li>
<li>Data format</li>
</ul>
</li>
<li>Comparison of errors left
<ul>
<li>Small example</li>
<li>Data to be reproduced</li>
<li>Steps to reproduce</li>
</ul>
</li>
<li>Thresholds
<ul>
<li>Data to be reproduced</li>
<li>Steps to reproduce</li>
</ul>
</li>
<li>DFR
<ul>
<li>Data to be reproduced</li>
<li>Steps to reproduce</li>
</ul>
</li>
<li>Concavity
<ul>
<li>Data to be reproduced</li>
<li>Steps to reproduce</li>
</ul>
</li>
<li>Performance
<ul>
<li>Data to be reproduced</li>
<li>Steps to reproduce</li>
</ul>
</li>
</ul>
</li>
<li>Figures</li>
<li>Exploring the PickyFix code</li>
<li>Conclusion</li>
</ul>

<h1>
<a id="user-content-abstract" class="anchor" href="#abstract" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Abstract</h1>
<p>This README serves as a guide to the supplementary material of our submission
to CHES 2022. Our 3 main objectives are:</p>
<ol>
<li>Explain how to reproduce our results</li>
<li>Identify our main original contribution - the implementation of PickFix</li>
<li>Explain our data and the corresponding visualization tools</li>
</ol>
<p><strong>Important notice</strong>: Our implementation is based on <a href="https://bikesuite.org/files/round2/add-impl/BIKE_Additional.2020.02.09.zip" rel="nofollow">BIKE Additional Implementation</a> by Drucker, Kostic and Gueron.
Therefore, most of the code in the <code>bike</code> directory comes from their implementation.
Our implementation of PickyFix is meant to be plugged in to their implementation, we tried to
isolate the majority of our code into the <code>bike/pickyfix</code> directory.</p>
<h1>
<a id="user-content-what-is-included-in-this-repository" class="anchor" href="#what-is-included-in-this-repository" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>What is included in this repository</h1>
<ul>
<li>
<p><code>bike</code>: The source code of BIKE and our decoder.
<strong>Most of this directory consists of BIKE Additional Implementation,
which is not our work.</strong>
Therefore, we only enumerate below the directories with our contributions:</p>
<ul>
<li>
<p><code>bike/experiments</code>: Each source in <code>bike/experiments</code> will
generate an executable that outputs a CSV corresponding to one experiment. This
is how we generated the data for most of the figures and tables in the paper.</p>
<ul>
<li>
<code>bike/experiments/compare_n_errors.c</code>: The experiment to compare the number of errors
left after one iteration of BGF and PickyFix with different values of <code>n_flips</code>.</li>
<li>
<code>bike/experiments/counters.c</code>: The experiment to compute the UPC counters.</li>
<li>
<code>bike/experiments/experiments.h</code>: Some common functions and definitions for the
majority of experiments.</li>
<li>
<code>bike/experiments/kem_internals.h</code>: Some static functions that are defined in
BIKE Additional Implementation <code>kem.c</code>, that are also used in our experiments.
Since we wanted to make the minimum amount of changes to BIKE Additional Implementation,
we preferred this approach instead of altering the functions to be non-static.</li>
<li>
<code>bike/experiments/main.c</code>: The main experiment used in this paper: the Decryption Failure
Rate (DFR) estimation for applying Vasseur's extrapolation framework.</li>
<li>
<code>bike/experiments/threshold.c</code>: The experiment to compute the thresholds used by BGF.</li>
</ul>
</li>
<li>
<p><code>bike/pickyfix</code>: This is where our implementation of PickyFix lives.</p>
<ul>
<li>
<code>bike/pickyfix/decode_internals.h</code>: Some static functions from the BGF decoder (
that lives in <code>decode/decode.c</code>). These functions are important for syndrome
recomputation and other common steps to bit-flipping decoding.</li>
<li>
<code>bike/pickyfix/pickyfix.c</code>: The entry point for the PickyFix decoder.</li>
<li>
<code>bike/pickyfix/pickyfix.h</code>: Definitions such as <code>n_flips</code> for each level and additional
<code>structs</code> and <code>typedefs</code>.</li>
<li>
<code>bike/pickyfix/Makefile</code>: The partial Makefile for this directory.</li>
<li>
<code>bike/pickyfix/secure_pickyfix_avx2.c</code>: The AVX2 implementation of PickyFix.
<strong>NOTICE: AT THIS MOMENT, THIS IS JUST A COPY OF THE PORTABLE IMPLEMENTATION.</strong>
We named it this way because of how the building process works.</li>
<li>
<code>bike/pickyfix/secure_pickyfix_avx512.c</code>: The AVX512 implementation of PickyFix.</li>
<li>
<code>bike/pickyfix/secure_pickyfix_portable.c</code>: The portable implementation of PickyFix.</li>
</ul>
</li>
<li>
<p><code>bike/run_compare_n_errors.sh</code>: Script to run instances of <code>bike/experiments/compare_n_errors.c</code>.</p>
</li>
<li>
<p><code>bike/run_performance_test.sh</code>: Script to run instances of <code>bike/experiments/perf.c</code>.</p>
</li>
<li>
<p><code>bike/run_threshold.sh</code>: Script to run instances of <code>bike/experiments/threshold.c</code>.</p>
</li>
</ul>
</li>
<li>
<p><code>data</code>: CSV files for results and setup of our experiments.
Each of its sub-directories correspond to a different experiment and contains
a set of CSV files.
The contents of this directory will be seen in more detail when discussing
the reproducibility.</p>
</li>
<li>
<p><code>analysis/dfr_experiment.py</code>: The <code>python</code> program to execute the DFR extrapolation experiment.</p>
</li>
<li>
<p><code>analysis/plotters/plots.py</code>: The <code>python</code> program to plot the data.</p>
</li>
</ul>
<h1>
<a id="user-content-bike-code---compiling-and-running" class="anchor" href="#bike-code---compiling-and-running" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>BIKE code - Compiling and Running</h1>
<p>Since we based our implementation in BIKE Additional Implementation by Drucker et al., we
kept the same building mechanism as they used.</p>
<h2>
<a id="user-content-compilation-flags" class="anchor" href="#compilation-flags" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Compilation Flags</h2>
<p><strong>Most important compilation flags inherited from BIKE Additional Implementation</strong>:</p>
<ul>
<li>
<code>USE_NIST_RAND</code> : Use the RNG from NIST.</li>
<li>
<code>USE_OPENSSL</code>   : Use OpenSSL for AES/SHA and GF2X multiplication.
OpenSSL must be installed on the platform.</li>
<li>
<code>OPENSSL_DIR</code>   : Set the path of the OpenSSL include/lib directories.</li>
<li>
<code>RDTSC</code>         : Measure time in cycles rather than in milliseconds.</li>
<li>
<code>VERBOSE</code>       : Add verbose (level:1-4 default:1).</li>
<li>
<code>AVX2</code>          : Compile with AVX2 support (to compile use GCC).</li>
<li>
<code>AVX512</code>        : Compile with AVX512 support (to compile use GCC).</li>
<li>
<code>LEVEL</code>         : Security level (1/3/5).</li>
</ul>
<p><strong>Additional compilation flags we used</strong>:</p>
<ul>
<li>
<code>R_BITS</code>: Defines the value of parameter <code>R_BITS</code> to be used for testing. This is specially important
for the DFR extrapolation framework.</li>
<li>
<code>ERROR_WEIGHT</code>: Defines the value of the error weight <code>T1</code> used for encryption. This is used for the concavity
tests with the exaggerated error weight.</li>
<li>
<code>TEST_PICKYFIX</code>: Use the PickyFix decoder.</li>
<li>
<code>TEST_BGF</code>: Use the BGF decoder.</li>
<li>
<code>MAX_IT</code>: Set the number of iterations for the decoders to use.</li>
</ul>
<h2>
<a id="user-content-the-need-for-make-clean-when-parameters-change" class="anchor" href="#the-need-for-make-clean-when-parameters-change" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>The need for <code>make clean</code> when parameters change</h2>
<p>We highly recommend that you run <code>make clean</code> when you change the compilation flags, otherwise the compiler
may have problems.</p>
<h2>
<a id="user-content-example" class="anchor" href="#example" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Example</h2>
<p>First <code>cd</code> to the <code>bike</code> directory. Then call <code>make</code> with the appropriate parameters.</p>
<p>Let us compile and test the PickyFix and BGF decoder in a system supporting AVX2 instructions for
<code>LEVEL = 1</code>. Since we want to see failures occurring, let us select the reduced value of <code>R_BITS = 9901</code>.</p>
<pre><code>$ make clean; make LEVEL=1 TEST_PICKYFIX=1 TEST_BGF=1 AVX2=1 R_BITS=9901
</code></pre>
<p>Let us see the arguments we can pass to the <code>./bin/main</code>, which consists of the simple DFR experiment.</p>
<pre><code>$ ./bin/main
Usage: ./bin/main &lt;number of tests&gt; &lt;seed&gt; &lt;number of threads&gt; [measure time (true|False)]
</code></pre>
<p>Now let us run it with 1 thread and see the result. See how it prints partial results to <code>stderr</code> with intervals
of 1000 tests. Furthermore, the last two rows show the final result: PickyFix failed in 35 while BGF
failed in 50 out of 10,000 tests.</p>
<pre><code>$ time ./bin/main 10000 1 1
decoder,n_iterations,level,r_bits,error_weight,n_failures,n_tests
BGF,5,1,9901,134,7,1000,thread0
PickyFix,5,1,9901,134,4,1000,thread0
BGF,5,1,9901,134,10,2000,thread0
PickyFix,5,1,9901,134,9,2000,thread0
BGF,5,1,9901,134,14,3000,thread0
PickyFix,5,1,9901,134,13,3000,thread0
BGF,5,1,9901,134,18,4000,thread0
PickyFix,5,1,9901,134,14,4000,thread0
BGF,5,1,9901,134,26,5000,thread0
PickyFix,5,1,9901,134,16,5000,thread0
BGF,5,1,9901,134,28,6000,thread0
PickyFix,5,1,9901,134,19,6000,thread0
BGF,5,1,9901,134,31,7000,thread0
PickyFix,5,1,9901,134,25,7000,thread0
BGF,5,1,9901,134,38,8000,thread0
PickyFix,5,1,9901,134,30,8000,thread0
BGF,5,1,9901,134,42,9000,thread0
PickyFix,5,1,9901,134,31,9000,thread0
BGF,5,1,9901,134,50,10000,thread0
PickyFix,5,1,9901,134,35,10000,thread0
BGF,5,1,9901,134,50,10000
PickyFix,5,1,9901,134,35,10000
./bin/main 10000 1 1  28.46s user 0.00s system 99% cpu 28.481 total
</code></pre>
<p>While this is a nice result for PickyFix vs. BGF, both using the default number of iterations <code>MAX_IT=5</code>, this
does not really say very much: a good decoder must perform well under the DFR extrapolation framework.
Next, we will see how to reproduce our results for the DFR extrapolation used in the paper.</p>
<h1>
<a id="user-content-reproducibility" class="anchor" href="#reproducibility" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Reproducibility</h1>
<p>We will now discuss how to reproduce the results presented in our paper.
Since all results are contained in the <code>data/</code> directory, we will describe how each of the data
was generated.</p>
<p><strong>Important:</strong> The results are meant to be fully reproducible when using the same seeds and number of threads.
If you found different results, please contact us so we can better understand what happened.</p>
<p><strong>Important:</strong> We recommend you use <a href="https://pypi.org/project/pipenv/" rel="nofollow">Pipenv</a> to install
the dependencies for the auxiliary python scripts.</p>
<h2>
<a id="user-content-counters" class="anchor" href="#counters" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Counters</h2>
<p>Let us start with the simple experiment: determine the UPC values for each counter</p>
<h3>
<a id="user-content-data-to-be-reproduced" class="anchor" href="#data-to-be-reproduced" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Data to be reproduced</h3>
<ul>
<li><code>data/counters/counters_level5.csv</code></li>
</ul>
<h3>
<a id="user-content-steps-to-reproduce" class="anchor" href="#steps-to-reproduce" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Steps to reproduce</h3>
<p>Let us compile and run the experiment and check that the reproduced data is indeed equal to our data file.</p>
<pre><code>$ mkdir -p reproduced/counters
$ make clean; make LEVEL=5 TEST_PICKYFIX=1 AVX2=1
$ ./bin/counters 1 &gt; reproduced/counters/counters_level5.csv
$ diff reproduced/counters/counters_level5.csv ../data/counters/counters_level5.csv
</code></pre>
<p>Now let us see the file generated.</p>
<pre><code>$ head reproduced/counters/counters_level5.csv
level,r_bits,error_weight,test,counter,n_right,n_wrong
# 0,threshold=86
5,40973,264,0,0,0,0
5,40973,264,0,1,0,0
5,40973,264,0,2,0,0
5,40973,264,0,3,0,0
5,40973,264,0,4,0,0
5,40973,264,0,5,0,0
5,40973,264,0,6,0,0
5,40973,264,0,7,0,0
</code></pre>
<h3>
<a id="user-content-data-format" class="anchor" href="#data-format" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Data format</h3>
<ul>
<li>
<code>#</code>: Lines starting with <code>#</code> are comments</li>
<li>
<code>level</code>: The security level (1/3/5)</li>
<li>
<code>r_bits</code>: The value of <code>R_BITS</code>
</li>
<li>
<code>error_weight</code>: The weight of the encryption error</li>
<li>
<code>test</code>: The ID of the test (remember we ran 1 test)</li>
<li>
<code>counter</code>: The UPC value between <code>0</code> and <code>DV</code>
</li>
<li>
<code>n_right</code>: Number of occurrences of the UPC <code>counter</code> within the <code>R_BITS - error_weight</code> right entries</li>
<li>
<code>n_wrong</code>: Number of occurrences of the UPC <code>counter</code> within the <code>error_weight</code> wrong entries</li>
</ul>
<h2>
<a id="user-content-comparison-of-errors-left" class="anchor" href="#comparison-of-errors-left" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Comparison of errors left</h2>
<p>The code for this test is in <code>bike/experiments/compare_n_errors.c</code>. It consists of computing
the average number of errors left after one iteration of BGF and one iteration of FixFlip with
different values of <code>nflips</code>.</p>
<p>Since this test is rather expensive, we let <code>nflips</code> be a multiple of five, and it is updated
according to the main for loop:</p>
<div class="highlight highlight-source-c"><pre><span class="pl-k">for</span> (<span class="pl-k">int</span> nflips = <span class="pl-c1">5</span>; nflips &lt;= MIN(T1, <span class="pl-c1">200</span>); nflips += <span class="pl-c1">5</span>)</pre></div>
<p>To run this experiment, we use the shell script <code>bike/run_compare_n_errors.sh</code>.
Given a security level (1/3/5), this will first build 24 executables for different numbers of <code>R_BITS</code>
and then run 24 threads of the <code>bike/experiments/compare_n_errors.c</code> program. If you may need to adjust the
code to your needs, according to the number of cores you are using.</p>
<h3>
<a id="user-content-small-example" class="anchor" href="#small-example" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Small example</h3>
<p>If you just want to examine the data with a quick test, just set a small value of <code>n_tests</code>. It
will take about 1 minute to compile all the different executable files, but it will not take too long to finish.</p>
<pre><code>$ time ./run_compare_n_errors.sh output_compare_n_errors 1 10 AVX2=1
Compiling code for level = 1 using r_bits = 9201
Compiling code for level = 1 using r_bits = 9301
Compiling code for level = 1 using r_bits = 9401
Compiling code for level = 1 using r_bits = 9501
Compiling code for level = 1 using r_bits = 9601
Compiling code for level = 1 using r_bits = 9701
Compiling code for level = 1 using r_bits = 9801
Compiling code for level = 1 using r_bits = 9901
Compiling code for level = 1 using r_bits = 10001
Compiling code for level = 1 using r_bits = 10101
Compiling code for level = 1 using r_bits = 10201
Compiling code for level = 1 using r_bits = 10301
Compiling code for level = 1 using r_bits = 10401
Compiling code for level = 1 using r_bits = 10501
Compiling code for level = 1 using r_bits = 10601
Compiling code for level = 1 using r_bits = 10701
Compiling code for level = 1 using r_bits = 10801
Compiling code for level = 1 using r_bits = 10901
Compiling code for level = 1 using r_bits = 11001
Compiling code for level = 1 using r_bits = 11101
Compiling code for level = 1 using r_bits = 11201
Compiling code for level = 1 using r_bits = 11301
Compiling code for level = 1 using r_bits = 11401
Compiling code for level = 1 using r_bits = 11501
Running!
All threads finished.
Results in output_compare_n_errors/output1.csv : ).
./run_compare_n_errors.sh output_compare_n_errors 1 10 AVX2=1  64.92s user 4.63s system 116% cpu 59.639 total
</code></pre>
<h3>
<a id="user-content-data-to-be-reproduced-1" class="anchor" href="#data-to-be-reproduced-1" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Data to be reproduced</h3>
<ul>
<li><code>data/compare_n_errors/n_errors.csv</code></li>
</ul>
<h3>
<a id="user-content-steps-to-reproduce-1" class="anchor" href="#steps-to-reproduce-1" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Steps to reproduce</h3>
<p>Let us compile and run the experiment and check that the reproduced data is indeed equal to our data file.</p>
<div class="highlight highlight-source-shell"><pre>$
<span class="pl-k">for</span> <span class="pl-smi">level</span> <span class="pl-k">in</span> 1 3 5<span class="pl-k">;</span> <span class="pl-k">do</span>
    mkdir -p reproduced/compare_n_errors/tmp<span class="pl-smi">$level</span>
    <span class="pl-c"><span class="pl-c">#</span> YOU MAY NEED TO ADJUST TO YOUR AVX SUPPORT BELOW</span>
    <span class="pl-k">time</span> ./run_compare_n_errors.sh reproduced/compare_n_errors/tmp<span class="pl-smi">$level</span> <span class="pl-smi">$level</span> 10000 AVX512=1
<span class="pl-k">done</span>
$ head -n 1 reproduced/compare_n_errors/tmp1/output1.csv <span class="pl-k">&gt;</span> reproduced/compare_n_errors/header.csv
$ tail -q -n +2 reproduced/compare_n_errors/tmp1/output1.csv \
    reproduced/compare_n_errors/tmp3/output3.csv \
    reproduced/compare_n_errors/tmp5/output5.csv <span class="pl-k">&gt;</span> reproduced/compare_n_errors/body.csv
$ cat reproduced/compare_n_errors/header.csv \
      reproduced/compare_n_errors/body.csv <span class="pl-k">&gt;</span> reproduced/compare_n_errors/n_errors.csv</pre></div>
<h2>
<a id="user-content-thresholds" class="anchor" href="#thresholds" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Thresholds</h2>
<p>The way this experiment works is very similar to the experiment above, but it is much faster because it uses
a fixed <code>n_flips</code> values when testing PickyFix. The script to run it is <code>bike/run_threshold.sh</code>. Using
<code>AVX2=1</code>, the test takes only a few minutes to run, considering level 1 parameters.</p>
<h3>
<a id="user-content-data-to-be-reproduced-2" class="anchor" href="#data-to-be-reproduced-2" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Data to be reproduced</h3>
<ul>
<li><code>data/threshold/level1.csv</code></li>
</ul>
<h3>
<a id="user-content-steps-to-reproduce-2" class="anchor" href="#steps-to-reproduce-2" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Steps to reproduce</h3>
<p>To minimize space, we put only the file for level 1, which is generated by.</p>
<pre><code>$ mkdir -p reproduced/threshold/tmp1
$ ./run_threshold.sh reproduced/threshold/tmp1 1 10000 AVX512=1  # YOU MAY NEED TO ADJUST TO YOUR AVX SUPPORT
$ mv reproduced/threshold/tmp1/output1.csv &gt; reproduced/threshold/level1.csv
</code></pre>
<p>However, we invite the reader to run the code below and see how the first threshold is
problematic also for levels 3 and 5.</p>
<div class="highlight highlight-source-shell"><pre>$
<span class="pl-k">for</span> <span class="pl-smi">level</span> <span class="pl-k">in</span> 1 3 5<span class="pl-k">;</span> <span class="pl-k">do</span>
    mkdir -p reproduced/threshold/tmp<span class="pl-smi">$level</span>
    <span class="pl-c"><span class="pl-c">#</span> YOU MAY NEED TO ADJUST TO YOUR AVX SUPPORT BELOW</span>
    <span class="pl-k">time</span> ./run_threshold.sh reproduced/threshold/tmp<span class="pl-smi">$level</span> <span class="pl-smi">$level</span> 10000 AVX512=1
<span class="pl-k">done</span>
$ head -n 1 reproduced/threshold/tmp1/output1.csv <span class="pl-k">&gt;</span> reproduced/threshold/header.csv
$ tail -q -n +2 reproduced/threshold/tmp1/output1.csv \
    reproduced/threshold/tmp3/output3.csv \
    reproduced/threshold/tmp5/output5.csv <span class="pl-k">&gt;</span> reproduced/threshold/body.csv
$ cat reproduced/threshold/header.csv \
      reproduced/threshold/body.csv <span class="pl-k">&gt;</span> reproduced/threshold/threshold.csv</pre></div>
<h2>
<a id="user-content-dfr" class="anchor" href="#dfr" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>DFR</h2>
<p><strong>IMPORTANT:</strong> This is the hardest test to reproduce, as it requires a lot of computing power.
Considering our server with 2x Intel® XeonTM Gold 5118 CPU at 2.30GHz, running with 24 of
its 48 threads, this experiment using AVX512 instructions took roughly 75 hours.</p>
<p>The setup for this test is in file <code>data/setup/dfr_experiment.csv</code>. Let us consider its content</p>
<pre><code>DECODER,LEVEL,MAX_IT_LIST,R_BITS,N_TESTS,EXPERIMENT_CMD,DFR_ESTIMATE
PickyFix,1,2,9001,10000,./bin/main,1.0
PickyFix,1,2,9101,10000,./bin/main,1.0
PickyFix,1,2,9201,10000,./bin/main,1.0
PickyFix,1,2,9301,10000,./bin/main,1.0
PickyFix,1,2,9401,10000,./bin/main,1.0
PickyFix,1,2,9501,100000,./bin/main,0.99955
PickyFix,1,2,9601,100000,./bin/main,0.98929
PickyFix,1,2,9701,100000,./bin/main,0.92285
PickyFix,1,2,9801,100000,./bin/main,0.69989
PickyFix,1,2,9901,100000,./bin/main,0.3564
PickyFix,1,2,10001,1000000,./bin/main,0.115497
PickyFix,1,2,10101,1000000,./bin/main,0.025546
PickyFix,1,2,10201,1000000,./bin/main,0.003832
PickyFix,1,2,10301,10000000,./bin/main,0.0004474
PickyFix,1,2,10351,10000000,./bin/main,0.0001448
...
</code></pre>
<p>Each line correspond to a DFR estimation using</p>
<ul>
<li>
<code>DECODER</code>: The decoder to use</li>
<li>
<code>LEVEL</code>: The security level</li>
<li>
<code>MAX_IT_LIST</code>: The number of iterations to use for the decoder</li>
<li>
<code>R_BITS</code>: Parameter <code>R_BITS</code>
</li>
<li>
<code>N_TESTS</code>: Number of tests for the DFR estimation</li>
<li>
<code>EXPERIMENT_CMD</code>: The command for the DFR estimation</li>
<li>
<code>DFR_ESTIMATE</code>: The DFR estimate that serves only as a guide when choosing parameters.</li>
</ul>
<p>This test is so important that we wrote a <code>python</code> program to run this test: <code>analysis/dfr_experiment.py</code></p>
<p>To run it, first we need to install its dependencies:</p>
<pre><code>$ cd analysis
$ pipenv install
$ pipenv shell
</code></pre>
<p>Under the virtual environment, we can run the script help to see how to use it:</p>
<pre><code>(analysis) $ ./dfr_experiment.py --help
usage: dfr_experiment.py [-h] [--AVX AVX] [--n_threads N_THREADS]
                         [--base_seed BASE_SEED] [--overwrite]
                         [--stop_if_ff_dfr_is_zero] bike_root experiment_csv working_dir

positional arguments:
  bike_root             path to root of BIKE implementation (where make should be run).
  experiment_csv        path to CSV file containing experiment parameters.
  working_dir           path to a non-existing directory that will be used for temporary files.

optional arguments:
  -h, --help            show this help message and exit
  --AVX AVX             Target AVX set to use: 2, 512 or leave empty if the portable implementation should be used.
  --n_threads N_THREADS
                        number of CPU threads to use. Default: use all.
  --base_seed BASE_SEED
                        seed used to generate other seeds for each run.
  --overwrite           flag to overwrite working directory
  --stop_if_ff_dfr_is_zero
                        flag to stop simulation when observed DFR is 0 for PickyFix

</code></pre>
<p>If you plan to use this experiment for real estimation, we highly recommend you run in a system with AVX512 support,
otherwise the test will take too much time.</p>
<p>In our system, we used the following command line:</p>
<pre><code>(analysis) $ ./dfr_experiment.py --AVX=512 --n_threads=24 ../bike ../data/setup/dfr_experiment.csv dfr_out
</code></pre>
<p>This will create a report file <code>dfr_out/dfr_results.out</code> that should be equal to <code>data/dfr/dfr_all.csv</code> of the format:</p>
<pre><code>decoder,n_iterations,level,error_weight,r_bits,n_failures,n_tests,dfr
PickyFix,2,1,134,9001,10000,10000,1.0
PickyFix,2,1,134,9101,10000,10000,1.0
PickyFix,2,1,134,9201,10000,10000,1.0
PickyFix,2,1,134,9301,10000,10000,1.0
PickyFix,2,1,134,9401,10000,10000,1.0
PickyFix,2,1,134,9501,99955,100000,0.99955
PickyFix,2,1,134,9601,98929,100000,0.98929
PickyFix,2,1,134,9701,92285,100000,0.92285
PickyFix,2,1,134,9801,69989,100000,0.69989
PickyFix,2,1,134,9901,35640,100000,0.3564
PickyFix,2,1,134,10001,115497,1000000,0.115497
PickyFix,2,1,134,10101,25546,1000000,0.025546
PickyFix,2,1,134,10201,3832,1000000,0.003832
PickyFix,2,1,134,10301,4474,10000000,0.0004474
PickyFix,2,1,134,10351,1448,10000000,0.0001448
...
</code></pre>
<h3>
<a id="user-content-data-to-be-reproduced-3" class="anchor" href="#data-to-be-reproduced-3" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Data to be reproduced</h3>
<ul>
<li><code>data/dfr/dfr_all.csv</code></li>
<li><code>data/dfr/bgf_level1.csv</code></li>
</ul>
<h3>
<a id="user-content-steps-to-reproduce-3" class="anchor" href="#steps-to-reproduce-3" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Steps to reproduce</h3>
<p><strong>IMPORTANT:</strong> To reproduce exactly our data, you will have to use exactly the same number of threads (i.e. 24).
This is a consequence of the way we seed our different threads.</p>
<p>Go to directory <code>analysis</code> and start the Python virtual environment with <code>pipenv</code>. Then</p>
<pre><code>$ mkdir -p reproduced/dfr
$ ./dfr_experiment.py --AVX=512 --n_threads=24 ../bike ../data/setup/dfr_experiment.csv reproduced/tmp_dfr
# THIS WILL TAKE A LONG TIME (~ 75 hours)
$ cp reproduced/tmp_dfr/dfr_results.out reproduced/dfr/dfr_all.csv
$
$ ./dfr_experiment.py --AVX=512 --n_threads=24 ../bike ../data/setup/dfr_experiment_bgf_level1_problem.csv reproduced/tmp_dfr_bgf
# THIS WILL TAKE A WHILE
$ cp reproduced/tmp_dfr_bgf/dfr_results.out reproduced/dfr/bgf_level1.csv
</code></pre>
<h2>
<a id="user-content-concavity" class="anchor" href="#concavity" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Concavity</h2>
<p>The concavity experiment is a simple variant of the DFR experiment but with an exaggerated error weight
and a lower number of tests (otherwise it would be too costly).</p>
<h3>
<a id="user-content-data-to-be-reproduced-4" class="anchor" href="#data-to-be-reproduced-4" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Data to be reproduced</h3>
<ul>
<li><code>data/concavity/bgf_level1.csv</code></li>
<li><code>data/concavity/pf_level1.csv</code></li>
</ul>
<h3>
<a id="user-content-steps-to-reproduce-4" class="anchor" href="#steps-to-reproduce-4" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Steps to reproduce</h3>
<p><strong>IMPORTANT:</strong> To reproduce exactly our data, you will have to use exactly the same number of threads (i.e. 24 or 40).
This is a consequence of the way we seed our different threads.</p>
<p>Go to directory <code>analysis</code> and start the Python virtual environment with <code>pipenv</code> as detailed in the
previous section (DFR). Then</p>
<pre><code>$ mkdir -p reproduced/concavity
$ ./dfr_experiment.py --AVX=512 --n_threads=24 ../bike ../data/setup/concavity_experiment_bgf_level1.csv reproduced/tmp_concavity_bgf
# THIS WILL TAKE A WHILE
$ cp reproduced/tmp_concavity_bgf/dfr_results.out reproduced/concavity/bgf_level1.csv
$ ./dfr_experiment.py --AVX=512 --n_threads=40 ../bike ../data/setup/concavity_experiment_pickyfix_level1.csv reproduced/tmp_concavity_pf
# THIS WILL TAKE A WHILE
$ cp reproduced/tmp_concavity_pf/dfr_results.out reproduced/concavity/pf_level1.csv
</code></pre>
<h2>
<a id="user-content-performance" class="anchor" href="#performance" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Performance</h2>
<p>We now show how we estimated the performance of the algorithm. This is the only result that
we expect you to see slightly different results than ours, because of the nature of this data.</p>
<h3>
<a id="user-content-data-to-be-reproduced-5" class="anchor" href="#data-to-be-reproduced-5" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Data to be reproduced</h3>
<ul>
<li><code>data/performance/all.csv</code></li>
</ul>
<h3>
<a id="user-content-steps-to-reproduce-5" class="anchor" href="#steps-to-reproduce-5" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Steps to reproduce</h3>
<p>In <code>bike</code> directory, run the shell script <code>./run_performance_test.sh</code> as below.</p>
<div class="highlight highlight-source-shell"><pre>$ mkdir -p reproduced/performance
$ ./run_performance_test.sh <span class="pl-k">|</span> tee reproduced/performance/all.csv
implementation,decoder,level,n_iterations,r_bits,cycles
avx512,BGF,1,5,12323,1253180.96
avx512,BGF,3,5,24659,3935917.32
avx512,BGF,5,5,40973,10873523.10
portable,BGF,1,5,12323,10340596.80
portable,BGF,3,5,24659,31178523.46
portable,BGF,5,5,40973,89649927.98
avx512,PickyFix,1,2,13829,992199.80
avx512,PickyFix,1,3,13109,1096159.36
avx512,PickyFix,1,4,12739,1213229.36
avx512,PickyFix,1,5,12413,1341189.42
avx512,PickyFix,3,2,27397,2903644.84
avx512,PickyFix,3,3,25867,3241641.76
avx512,PickyFix,3,4,25189,3633758.88
avx512,PickyFix,3,5,24677,4046768.14
avx512,PickyFix,5,2,41411,7190184.46
avx512,PickyFix,5,3,39901,8228689.02
avx512,PickyFix,5,4,39163,9360594.18
avx512,PickyFix,5,5,39019,10544398.68
portable,PickyFix,1,2,13829,8581052.98
portable,PickyFix,1,3,13109,9612084.50
portable,PickyFix,1,4,12739,10861147.42
portable,PickyFix,1,5,12413,12170507.62
portable,PickyFix,3,2,27397,23751521.86
portable,PickyFix,3,3,25867,27262014.12
portable,PickyFix,3,4,25189,30673611.46
portable,PickyFix,3,5,24677,34596916.80
portable,PickyFix,5,2,41411,61683202.52
portable,PickyFix,5,3,39901,71916444.44
portable,PickyFix,5,4,39163,82147943.52</pre></div>
<h1>
<a id="user-content-figures" class="anchor" href="#figures" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Figures</h1>
<p>The figures are generated by <code>analysis/plotters/plots.py</code>.</p>
<p>We believe that it is useful to make this file available as it can make it easier for researchers
trying to explore the data and find better parameters for PickyFix or even variants of BGF.</p>
<p>To use it, you'll need to activate the appropriate <code>pipenv</code> with:</p>
<div class="highlight highlight-source-shell"><pre>$ <span class="pl-c1">cd</span> analysis/plotters/
$ pipenv install
$ pipenv shell
$ ipython
Python 3.9.5 (default, May  4 2021, 03:36:27)
Type <span class="pl-s"><span class="pl-pds">'</span>copyright<span class="pl-pds">'</span></span>, <span class="pl-s"><span class="pl-pds">'</span>credits<span class="pl-pds">'</span></span> or <span class="pl-s"><span class="pl-pds">'</span>license<span class="pl-pds">'</span></span> <span class="pl-k">for</span> more information
IPython 8.1.1 -- An enhanced Interactive Python. Type <span class="pl-s"><span class="pl-pds">'</span>?<span class="pl-pds">'</span></span> <span class="pl-k">for</span> help.</pre></div>
<p>Now, inside <code>ipython</code> we can generate all plots with a simple sequence of steps. The plots
will consider the data from the <code>data</code> directory.</p>
<div class="highlight highlight-source-python"><pre>$
<span class="pl-v">In</span> [<span class="pl-c1">1</span>]: <span class="pl-s1">run</span> <span class="pl-s1">plots</span>.<span class="pl-s1">py</span>

<span class="pl-v">In</span> [<span class="pl-c1">2</span>]: <span class="pl-en">latexify_lncs</span>()

<span class="pl-v">In</span> [<span class="pl-c1">3</span>]: <span class="pl-s1">mkdir</span> <span class="pl-s1">figures</span>

<span class="pl-v">In</span> [<span class="pl-c1">4</span>]: <span class="pl-en">generate_all_plots</span>(<span class="pl-s">'figures'</span>)

<span class="pl-v">In</span> [<span class="pl-c1">7</span>]: <span class="pl-s1">ls</span> <span class="pl-s1">figures</span><span class="pl-c1">/</span>
<span class="pl-s1">bgf_threshold_problem</span>.<span class="pl-s1">pdf</span>  <span class="pl-s1">concavity_bgf_level1</span>.<span class="pl-s1">pdf</span>  <span class="pl-s1">counters_level5</span>.<span class="pl-s1">pdf</span>  <span class="pl-s1">dfr_extrapolation_level1</span>.<span class="pl-s1">pdf</span>
<span class="pl-s1">compare_n_errors</span>.<span class="pl-s1">pdf</span>       <span class="pl-s1">concavity_pf_level1</span>.<span class="pl-s1">pdf</span>   <span class="pl-s1">dfr_bgf_level1</span>.<span class="pl-s1">pdf</span>   <span class="pl-s1">pickyfix_dfr</span>.<span class="pl-s1">pdf</span></pre></div>
<p>Notice that these are the plots used in the paper.</p>
<h1>
<a id="user-content-exploring-the-pickyfix-code" class="anchor" href="#exploring-the-pickyfix-code" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Exploring the PickyFix code</h1>
<p>We suggest to start by opening file <code>pickyfix/pickyfix.c</code>. There, you will find
the <code>decode_pickyfix</code> function which implements PickyFix in a way such that one
can easily match steps in the corresponding <code>PickyFix</code> Algorithm in the paper.</p>
<div class="highlight highlight-source-c"><pre><span class="pl-c"><span class="pl-c">//</span> Function: decode_pickyfix</span>
<span class="pl-c"><span class="pl-c">//</span> ------------------------</span>
<span class="pl-c"><span class="pl-c">//</span></span>
<span class="pl-c"><span class="pl-c">//</span>  The full decoding of an error vector, given a ciphertext. This is the entry</span>
<span class="pl-c"><span class="pl-c">//</span>  point of the contribution of our paper.</span>
<span class="pl-c"><span class="pl-c">//</span></span>
<span class="pl-c"><span class="pl-c">//</span>  We propose this algorithm as a replacement for BGF. The reader is invited</span>
<span class="pl-c"><span class="pl-c">//</span>  to inspect the code for decode_bgf in decode/decode.c to see the similarities</span>
<span class="pl-c"><span class="pl-c">//</span>  (and differences) between the two.</span>
<span class="pl-c"><span class="pl-c">//</span></span>
<span class="pl-c"><span class="pl-c">//</span>  Notice that: for each security level, a different number of flips is made</span>
<span class="pl-c"><span class="pl-c">//</span>  in the first iteration. This is defined by the constant FIXFLIP_HEAD_N_FLIPS.</span>
<span class="pl-c"><span class="pl-c">//</span>  Furthermore, notice that the threshold used by bitflip_iter is the same</span>
<span class="pl-c"><span class="pl-c">//</span>  as the one used in BGF, but in FixFlip, they are used at different times.</span>
<span class="pl-c"><span class="pl-c">//</span></span>
<span class="pl-c"><span class="pl-c">//</span> Input arguments:</span>
<span class="pl-c"><span class="pl-c">//</span>  - syndrome_t *original_s: The target syndrome</span>
<span class="pl-c"><span class="pl-c">//</span>  - ct_t *ct: The ciphertext</span>
<span class="pl-c"><span class="pl-c">//</span>  - sk_t *sk: The secret key</span>
<span class="pl-c"><span class="pl-c">//</span></span>
<span class="pl-c"><span class="pl-c">//</span> Output arguments:</span>
<span class="pl-c"><span class="pl-c">//</span>  - sp</span>
<span class="pl-c1">ret_t</span>
<span class="pl-en">decode_pickyfix</span>(OUT <span class="pl-c1">split_e_t</span> *e,
                IN <span class="pl-k">const</span> <span class="pl-c1">syndrome_t</span> *original_s,
                IN <span class="pl-k">const</span> <span class="pl-c1">ct_t</span> *ct,
                IN <span class="pl-k">const</span> <span class="pl-c1">sk_t</span> *sk) {
    <span class="pl-c1">syndrome_t</span> s;

    <span class="pl-c1">memset</span>(e, <span class="pl-c1">0</span>, <span class="pl-k">sizeof</span>(*e));
    s = *original_s;
    <span class="pl-c1">dup</span>(&amp;s);

    <span class="pl-k">for</span> (<span class="pl-k">int</span> i = <span class="pl-c1">0</span>; i &lt; MAX_IT; i++) {
        <span class="pl-k">if</span> (i == <span class="pl-c1">0</span>) {
            <span class="pl-c1">GUARD</span>(<span class="pl-c1">fixflip_iter</span>(e, &amp;s, FIXFLIP_HEAD_N_FLIPS, ct, sk));
            <span class="pl-c1">GUARD</span>(<span class="pl-c1">pickyflip_iter</span>(e, &amp;s, <span class="pl-c1">get_threshold</span>(&amp;s), (DV + <span class="pl-c1">1</span>) / <span class="pl-c1">2</span>, ct, sk));
            <span class="pl-c1">GUARD</span>(<span class="pl-c1">pickyflip_iter</span>(e, &amp;s, <span class="pl-c1">get_threshold</span>(&amp;s), (DV + <span class="pl-c1">1</span>) / <span class="pl-c1">2</span>, ct, sk));
        } <span class="pl-k">else</span> {
            <span class="pl-c1">GUARD</span>(<span class="pl-c1">pickyflip_iter</span>(e, &amp;s, <span class="pl-c1">get_threshold</span>(&amp;s), (DV + <span class="pl-c1">1</span>) / <span class="pl-c1">2</span>, ct, sk));
        }
    }
    <span class="pl-k">if</span> (<span class="pl-c1">r_bits_vector_weight</span>((<span class="pl-c1">r_t</span> *)s.<span class="pl-smi">qw</span>) &gt; <span class="pl-c1">0</span>) {
        <span class="pl-c1">DMSG</span>(<span class="pl-s"><span class="pl-pds">"</span>    Weight of e: <span class="pl-c1">%lu</span><span class="pl-cce">\n</span><span class="pl-pds">"</span></span>,
             <span class="pl-c1">r_bits_vector_weight</span>(&amp;e-&gt;<span class="pl-smi">val</span>[<span class="pl-c1">0</span>]) + <span class="pl-c1">r_bits_vector_weight</span>(&amp;e-&gt;<span class="pl-smi">val</span>[<span class="pl-c1">1</span>]));
        <span class="pl-c1">DMSG</span>(<span class="pl-s"><span class="pl-pds">"</span>    Weight of syndrome: <span class="pl-c1">%lu</span><span class="pl-cce">\n</span><span class="pl-pds">"</span></span>, <span class="pl-c1">r_bits_vector_weight</span>((<span class="pl-c1">r_t</span> *)s.<span class="pl-smi">qw</span>));
        <span class="pl-c1">BIKE_ERROR</span>(E_DECODING_FAILURE);
    }

    <span class="pl-k">return</span> SUCCESS;
}</pre></div>
<p>Then, the reader is invited to explore the PickyFlip iteration in function <code>pickyflip_iter</code>
in the same file <code>pickyfix/pickyfix.c</code>. We suggest that the reader compares it with
the implementation of the auxiliary iteration for BGF, that can be found in
function <code>find_err1</code> from file <code>decode/decode.c:</code>. The reader will see that our implementation
of this function is completely based on the BGF implementation, and we even kept their original
comments.</p>
<div class="highlight highlight-source-c"><pre><span class="pl-c"><span class="pl-c">//</span> Function: pickyflip_iter</span>
<span class="pl-c"><span class="pl-c">//</span> ----------------------</span>
<span class="pl-c"><span class="pl-c">//</span></span>
<span class="pl-c"><span class="pl-c">//</span>  IMPORTANT NOTICE:</span>
<span class="pl-c"><span class="pl-c">//</span>  ================</span>
<span class="pl-c"><span class="pl-c">//</span>  TO IMPLEMENT pickyflip_iter, WE REUSED FUNCTION find_err1, ORIGINALLY IMPLEMENTED BY</span>
<span class="pl-c"><span class="pl-c">//</span>  Nir Drucker, Shay Gueron, and Dusan Kostic, AWS Cryptographic Algorithms Group.</span>
<span class="pl-c"><span class="pl-c">//</span>  (ndrucker@amazon.com, gueron@amazon.com, dkostic@amazon.com)</span>
<span class="pl-c"><span class="pl-c">//</span>  ===========================================================================</span>
<span class="pl-c"><span class="pl-c">//</span></span>
<span class="pl-c"><span class="pl-c">//</span></span>
<span class="pl-c"><span class="pl-c">//</span>  Flips `n_flips` bits of a partial error vector `e` inplace. Additionally, the syndrome is</span>
<span class="pl-c"><span class="pl-c">//</span>  recomputed for the new value of `e` and `syndrome` is updated.</span>
<span class="pl-c"><span class="pl-c">//</span></span>
<span class="pl-c"><span class="pl-c">//</span> Input arguments:</span>
<span class="pl-c"><span class="pl-c">//</span>  - split e_t *e: The partial error vector up to this point.</span>
<span class="pl-c"><span class="pl-c">//</span>  - syndrome_t *syndrome: The syndrome</span>
<span class="pl-c"><span class="pl-c">//</span>  - uint8_t threshold_in: The UPC threshold for flipping a bit from 0 to 1</span>
<span class="pl-c"><span class="pl-c">//</span>  - uint8_t threshold_out: The UPC threshold for flipping a bit from 1 to 0</span>
<span class="pl-c"><span class="pl-c">//</span>  - ct_t *ct: The ciphertext (used to recomputed the syndrome after flipping bits of e)</span>
<span class="pl-c"><span class="pl-c">//</span>  - sk_t *sk: The secret key (used to recomputed the syndrome after flipping bits of e)</span>
<span class="pl-c"><span class="pl-c">//</span></span>
<span class="pl-c"><span class="pl-c">//</span> Output arguments:</span>
<span class="pl-c"><span class="pl-c">//</span>  - split_e_t *e: The partial error vectors after the n_flips bits were flipped</span>
<span class="pl-c"><span class="pl-c">//</span>  - syndrome_t *syndrome: The recomputed syndrome for the new error vector `e`</span>
<span class="pl-c"><span class="pl-c">//</span></span>
<span class="pl-c1">ret_t</span>
<span class="pl-en">pickyflip_iter</span>(OUT <span class="pl-c1">split_e_t</span> *e,
               IN <span class="pl-c1">syndrome_t</span> *  syndrome,
               IN <span class="pl-k">const</span> <span class="pl-c1">uint8_t</span> threshold_in,
               IN <span class="pl-k">const</span> <span class="pl-c1">uint8_t</span> threshold_out,
               IN <span class="pl-k">const</span> <span class="pl-c1">ct_t</span> *ct,
               IN <span class="pl-k">const</span> <span class="pl-c1">sk_t</span> *sk) {
    <span class="pl-c1">DEFER_CLEANUP</span>(<span class="pl-c1">syndrome_t</span> rotated_syndrome = {<span class="pl-c1">0</span>}, syndrome_cleanup);
    <span class="pl-c1">DEFER_CLEANUP</span>(<span class="pl-c1">upc_t</span> upc, upc_cleanup);

    <span class="pl-c1">split_e_t</span> e_copy;
    <span class="pl-c1">memcpy</span>(&amp;e_copy, e, <span class="pl-k">sizeof</span>(*e));

    <span class="pl-c1">assert</span>(threshold_in &gt;= threshold_out);

    <span class="pl-k">for</span> (<span class="pl-c1">uint32_t</span> i = <span class="pl-c1">0</span>; i &lt; N0; i++) {
        <span class="pl-c"><span class="pl-c">//</span> UPC must start from zero at every iteration</span>
        <span class="pl-c1">memset</span>(&amp;upc, <span class="pl-c1">0</span>, <span class="pl-k">sizeof</span>(upc));

        <span class="pl-c"><span class="pl-c">//</span> 1) Right-rotate the syndrome for every secret key set bit index</span>
        <span class="pl-c"><span class="pl-c">//</span>    Then slice-add it to the UPC array.</span>
        <span class="pl-k">for</span> (<span class="pl-c1">size_t</span> j = <span class="pl-c1">0</span>; j &lt; DV; j++) {
            <span class="pl-c1">rotate_right</span>(&amp;rotated_syndrome, syndrome, sk-&gt;<span class="pl-smi">wlist</span>[i].<span class="pl-smi">val</span>[j]);
            <span class="pl-c1">bit_sliced_adder</span>(&amp;upc, &amp;rotated_syndrome, <span class="pl-c1">LOG2_MSB</span>(j + <span class="pl-c1">1</span>));
        }

        <span class="pl-c"><span class="pl-c">//</span> 2) Subtract the threshold from the UPC counters</span>
        <span class="pl-c1">bit_slice_full_subtract</span>(&amp;upc, threshold_out); <span class="pl-c"><span class="pl-c">//</span> threshold_in &gt; threshold_out</span>

        <span class="pl-c"><span class="pl-c">//</span> 3) Update the errors vector.</span>
        <span class="pl-c"><span class="pl-c">//</span>    The last slice of the UPC array holds the MSB of the accumulated</span>
        <span class="pl-c"><span class="pl-c">//</span>    values minus the threshold. Every zero bit indicates a potential</span>
        <span class="pl-c"><span class="pl-c">//</span>    error bit.</span>
        <span class="pl-k">const</span> <span class="pl-c1">r_t</span> *last_slice_out = &amp;(upc.<span class="pl-smi">slice</span>[SLICES - <span class="pl-c1">1</span>].<span class="pl-smi">u</span>.<span class="pl-smi">r</span>.<span class="pl-smi">val</span>);
        <span class="pl-k">for</span> (<span class="pl-c1">size_t</span> j = <span class="pl-c1">0</span>; j &lt; R_SIZE; j++) {
            <span class="pl-k">const</span> <span class="pl-c1">uint8_t</span> sum_msb = (~last_slice_out-&gt;<span class="pl-smi">raw</span>[j]);
            e-&gt;<span class="pl-smi">val</span>[i].<span class="pl-smi">raw</span>[j] ^= ((e_copy.<span class="pl-smi">val</span>[i].<span class="pl-smi">raw</span>[j]) &amp; sum_msb);
        }
        e-&gt;<span class="pl-smi">val</span>[i].<span class="pl-smi">raw</span>[R_SIZE - <span class="pl-c1">1</span>] &amp;= LAST_R_BYTE_MASK;

        <span class="pl-c"><span class="pl-c">//</span> Now we have to consider the bits that are 0 to be flipped to 1.</span>
        <span class="pl-c"><span class="pl-c">//</span> This is controlled by theshold_in. Since upc was already</span>
        <span class="pl-c"><span class="pl-c">//</span> subtracted by threshold_out, we just need to subtract it by</span>
        <span class="pl-c"><span class="pl-c">//</span> (threshold_in - threshold_out)</span>
        <span class="pl-c1">bit_slice_full_subtract</span>(&amp;upc, threshold_in - threshold_out);
        <span class="pl-k">const</span> <span class="pl-c1">r_t</span> *last_slice_in = &amp;(upc.<span class="pl-smi">slice</span>[SLICES - <span class="pl-c1">1</span>].<span class="pl-smi">u</span>.<span class="pl-smi">r</span>.<span class="pl-smi">val</span>);
        <span class="pl-k">for</span> (<span class="pl-c1">size_t</span> j = <span class="pl-c1">0</span>; j &lt; R_SIZE; j++) {
            <span class="pl-k">const</span> <span class="pl-c1">uint8_t</span> sum_msb = (~last_slice_in-&gt;<span class="pl-smi">raw</span>[j]);
            e-&gt;<span class="pl-smi">val</span>[i].<span class="pl-smi">raw</span>[j] ^= (~(e_copy.<span class="pl-smi">val</span>[i].<span class="pl-smi">raw</span>[j]) &amp; sum_msb);
        }

        <span class="pl-c"><span class="pl-c">//</span> Ensure that the padding bits (upper bits of the last byte) are zero so</span>
        <span class="pl-c"><span class="pl-c">//</span> they will not be included in the multiplication and in the hash</span>
        <span class="pl-c"><span class="pl-c">//</span> function.</span>
        e-&gt;<span class="pl-smi">val</span>[i].<span class="pl-smi">raw</span>[R_SIZE - <span class="pl-c1">1</span>] &amp;= LAST_R_BYTE_MASK;
    }

    <span class="pl-c1">GUARD</span>(<span class="pl-c1">recompute_syndrome</span>(syndrome, ct, sk, e));
    <span class="pl-k">return</span> SUCCESS;
}</pre></div>
<p>Now, we invite you to explore the FixFlip iteration. This consists of a very simple looking function
<code>fixflip_iter</code> in file <code>pickyfix/pickyfix.c</code> that starts by computing the UPC in non-bitsliced
format <code>ff_upc</code>, and then calling the <code>flip_worst_fit_indexes</code> that flips the <code>n_flips</code> bits
of <code>e</code> that have the highest corresponding UPC values.</p>
<div class="highlight highlight-source-c"><pre><span class="pl-c"><span class="pl-c">//</span> Function: fixflip_iter</span>
<span class="pl-c"><span class="pl-c">//</span> ----------------------</span>
<span class="pl-c"><span class="pl-c">//</span></span>
<span class="pl-c"><span class="pl-c">//</span>  Flips `n_flips` bits of a partial error vector `e` inplace. Additionally, the syndrome is</span>
<span class="pl-c"><span class="pl-c">//</span>  recomputed for the new value of `e` and `syndrome` is updated.</span>
<span class="pl-c"><span class="pl-c">//</span></span>
<span class="pl-c"><span class="pl-c">//</span> Input arguments:</span>
<span class="pl-c"><span class="pl-c">//</span>  - split e_t *e: The partial error vector up to this point.</span>
<span class="pl-c"><span class="pl-c">//</span>  - syndrome_t *syndrome: The syndrome</span>
<span class="pl-c"><span class="pl-c">//</span>  - uint32_t n_flips: The number of bits to be flipped</span>
<span class="pl-c"><span class="pl-c">//</span>  - ct_t *ct: The ciphertext (used to recomputed the syndrome after flipping bits of e)</span>
<span class="pl-c"><span class="pl-c">//</span>  - sk_t *sk: The secret key (used to recomputed the syndrome after flipping bits of e)</span>
<span class="pl-c"><span class="pl-c">//</span></span>
<span class="pl-c"><span class="pl-c">//</span> Output arguments:</span>
<span class="pl-c"><span class="pl-c">//</span>  - split_e_t *e: The partial error vectors after the n_flips bits were flipped</span>
<span class="pl-c"><span class="pl-c">//</span>  - syndrome_t *syndrome: The recomputed syndrome for the new error vector `e`</span>
<span class="pl-c"><span class="pl-c">//</span></span>
<span class="pl-c1">ret_t</span>
<span class="pl-en">fixflip_iter</span>(OUT <span class="pl-c1">split_e_t</span> *e,
             OUT <span class="pl-c1">syndrome_t</span> *  syndrome,
             IN <span class="pl-k">const</span> <span class="pl-c1">uint32_t</span> n_flips,
             IN <span class="pl-k">const</span> <span class="pl-c1">ct_t</span> *ct,
             IN <span class="pl-k">const</span> <span class="pl-c1">sk_t</span> *sk) {

    <span class="pl-c1">fixflip_upc_t</span> ff_upc;
    <span class="pl-c1">memset</span>(&amp;ff_upc, <span class="pl-c1">0</span>, <span class="pl-k">sizeof</span>(ff_upc));

    <span class="pl-c1">get_upc</span>(&amp;ff_upc, syndrome, sk-&gt;<span class="pl-smi">wlist</span>);
    <span class="pl-c1">flip_worst_fit_indexes</span>(e, &amp;ff_upc, n_flips);

    <span class="pl-c1">GUARD</span>(<span class="pl-c1">recompute_syndrome</span>(syndrome, ct, sk, e));
    <span class="pl-k">return</span> SUCCESS;
}</pre></div>
<p>As one can guess, the complexity of the implementation is behind the <code>flip_worst_fit_indexes</code> function,
that we will explore next. This function starts by obtaining the FixFlip threshold, which in the
paper consists of an UPC threshold <code>tau</code> and the number <code>n_tau</code> of UPC equal to <code>tau</code> that must
be flipped. In the implementation, this pair is managed by type <code>fixflip_threshold_t</code>.</p>
<p>Then it runs through the bits <code>2 * R_BITS</code> and flips them according to the FixFlip threshold.
This is done by the main <code>for</code> loop is just responsible for flipping bits based on their UPC values
with care not to flip more than <code>n_flips</code> bits (which, remember, is the main function of
having <code>n_tau</code> represented by <code>ff_threshold.n_equal_threshold</code>).</p>
<p>Below, we consider function <code>flip_worst_fit_indexes</code> from the portable implementation
in file <code>secure_pickyfix_portable.c</code>.</p>
<p>First consider the UNSAFE non-randomized variant. This is used for extrapolation purposes.
This function is unsafe because it has a bias towards flipping bits to the left of the error
vector, among those whose UPC are equal to the threshold tau.</p>
<div class="highlight highlight-source-c"><pre><span class="pl-c1">uint32_t</span>
<span class="pl-en">flip_worst_fit_indexes</span>(OUT <span class="pl-c1">split_e_t</span> *e, IN <span class="pl-c1">fixflip_upc_t</span> *ff_upc, IN <span class="pl-c1">uint32_t</span> n_flips) {
    <span class="pl-c1">uint32_t</span> vals[DV + <span class="pl-c1">1</span>] = {<span class="pl-c1">0</span>};

    <span class="pl-c1">fixflip_threshold_t</span> ff_threshold = {<span class="pl-c1">0</span>};
    <span class="pl-c1">get_fixflip_threshold</span>(&amp;ff_threshold, ff_upc, n_flips);

    <span class="pl-c1">uint8_t</span> e_decomp[<span class="pl-c1">2</span> * R_BITS] = {<span class="pl-c1">0</span>};
    <span class="pl-c1">decompress_e</span>(e_decomp, e);

    <span class="pl-c"><span class="pl-c">//</span> The two variables bellow count the number of UPC counters that are found to be</span>
    <span class="pl-c"><span class="pl-c">//</span> equal and greater than the FixFlip threshold computed by get_fixflip_threshold.</span>
    <span class="pl-c1">uint32_t</span> n_found_eq_thresh = <span class="pl-c1">0</span>;
    <span class="pl-c1">uint32_t</span> n_found_gt_thresh = <span class="pl-c1">0</span>;
    <span class="pl-c"><span class="pl-c">//</span> By the end of the loop, it is expected that:</span>
    <span class="pl-c"><span class="pl-c">//</span>      n_found_eq_thresh = ff_threshold.n_equal_threshold</span>
    <span class="pl-c"><span class="pl-c">//</span>      n_found_gt_thresh + n_found_eq_thresh = n_flips</span>

    <span class="pl-c"><span class="pl-c">//</span> Runs through all the 2*R_BITS UPC counters</span>
    <span class="pl-k">for</span> (<span class="pl-c1">uint32_t</span> i = <span class="pl-c1">0</span>; i &lt; <span class="pl-c1">2</span> * R_BITS; i++) {
        <span class="pl-c1">uint8_t</span> counter = <span class="pl-c1">upc_for_index</span>(ff_upc, i);

        <span class="pl-c"><span class="pl-c">//</span> mask_gt assumes the following values:</span>
        <span class="pl-c"><span class="pl-c">//</span>      0 if the current counter is &lt;= ff_threshold.threshold</span>
        <span class="pl-c"><span class="pl-c">//</span>      1 otherwise.</span>
        <span class="pl-c1">uint32_t</span> mask_gt = <span class="pl-c1">1</span> + <span class="pl-c1">secure_l32_mask</span>(ff_threshold.<span class="pl-smi">threshold</span>, counter);
        n_found_gt_thresh += mask_gt;

        <span class="pl-c"><span class="pl-c">//</span> mask_eq assumes the following values:</span>
        <span class="pl-c"><span class="pl-c">//</span>      0 if current counter is == ff_threshold.threshold AND if</span>
        <span class="pl-c"><span class="pl-c">//</span>           n_found_eq_thresh &lt; ff_threshold.n_equal_threshold</span>
        <span class="pl-c"><span class="pl-c">//</span>      1 otherwise.</span>
        <span class="pl-c"><span class="pl-c">//</span> Therefore, it controls if the corresponding index `i` will be chosen to</span>
        <span class="pl-c"><span class="pl-c">//</span> flipped, when its counter is equal to the FixFlip threshold.</span>
        <span class="pl-c"><span class="pl-c">//</span></span>
        <span class="pl-c"><span class="pl-c">//</span> Remember that this is done because we cannot flip all bits whose counter is equal</span>
        <span class="pl-c"><span class="pl-c">//</span> to the threshold, because we risk flipping more than n_flips bits.</span>
        <span class="pl-c1">uint32_t</span> mask_eq = <span class="pl-c1">secure_cmp32</span>(counter, ff_threshold.<span class="pl-smi">threshold</span>);
        mask_eq &amp;= <span class="pl-c1">1</span> + <span class="pl-c1">secure_l32_mask</span>(n_found_eq_thresh, ff_threshold.<span class="pl-smi">n_equal_threshold</span>);

        n_found_eq_thresh += mask_eq;
        e_decomp[i] ^= (mask_gt | mask_eq);
    }
    <span class="pl-c1">assert</span>(n_found_eq_thresh == ff_threshold.<span class="pl-smi">n_equal_threshold</span>);
    <span class="pl-c1">assert</span>(n_found_gt_thresh == n_flips - ff_threshold.<span class="pl-smi">n_equal_threshold</span>);

    <span class="pl-c1">compress_e</span>(e, e_decomp);

    <span class="pl-k">return</span> ff_threshold.<span class="pl-smi">threshold</span>;
}</pre></div>
<p>Now compare it to the <strong>SAFE randomized</strong> variant, which has no bias when flipping bits.
This should be used in real-world systems code and is used by default in our code
(except under the extrapolation framework).
Its usage is controlled by the default definition
<code>#define USE_RANDOMIZED_SELECTION_OF_EQ_THRESHOLD_BITS</code> in <code>bike/pickyfix/pickyfix.h</code>.</p>
<div class="highlight highlight-source-c"><pre><span class="pl-c1">uint32_t</span>
<span class="pl-en">flip_worst_fit_indexes</span>(OUT <span class="pl-c1">split_e_t</span> *e, IN <span class="pl-c1">fixflip_upc_t</span> *ff_upc, IN <span class="pl-c1">uint32_t</span> n_flips) {
    <span class="pl-c1">DEFER_CLEANUP</span>(<span class="pl-c1">uint32_t</span> vals[DV + <span class="pl-c1">1</span>] = {<span class="pl-c1">0</span>}, vals_cleanup);

    <span class="pl-c1">fixflip_threshold_t</span> ff_threshold = {<span class="pl-c1">0</span>};
    <span class="pl-c1">get_fixflip_threshold</span>(&amp;ff_threshold, ff_upc, n_flips);

    <span class="pl-c1">uint8_t</span> e_decomp[<span class="pl-c1">2</span> * R_BITS] = {<span class="pl-c1">0</span>};
    <span class="pl-c1">decompress_e</span>(e_decomp, e);

    <span class="pl-c1">uint32_t</span> total_upc_counters_eq_threshold = ff_threshold.<span class="pl-smi">total_equal_threshold</span>;
    <span class="pl-c1">uint64_t</span> eq_flip_flags[N_FLIP_FLAGS_BLOCKS] = {<span class="pl-c1">0</span>};
    <span class="pl-c1">init_eq_flip_flags</span>(eq_flip_flags, &amp;ff_threshold);
    <span class="pl-c1">secure_shuffle_eq_flip_flags</span>(eq_flip_flags, &amp;ff_threshold, total_upc_counters_eq_threshold);
    <span class="pl-c1">uint32_t</span> current_eq_weight = <span class="pl-c1">0</span>;

    <span class="pl-c"><span class="pl-c">//</span> The two variables bellow count the number of UPC counters that are found to be</span>
    <span class="pl-c"><span class="pl-c">//</span> equal and greater than the FixFlip threshold computed by get_fixflip_threshold.</span>
    <span class="pl-c1">uint32_t</span> n_found_eq_thresh = <span class="pl-c1">0</span>;
    <span class="pl-c1">uint32_t</span> n_found_gt_thresh = <span class="pl-c1">0</span>;
    <span class="pl-c"><span class="pl-c">//</span> By the end of the loop, it is expected that:</span>
    <span class="pl-c"><span class="pl-c">//</span>      n_found_eq_thresh = ff_threshold.n_equal_threshold</span>
    <span class="pl-c"><span class="pl-c">//</span>      n_found_gt_thresh + n_found_eq_thresh = n_flips</span>

    <span class="pl-c1">uint32_t</span> next_32_flags = <span class="pl-c1">0</span>;
    <span class="pl-c1">uint32_t</span> base = <span class="pl-c1">0</span>;

    <span class="pl-c"><span class="pl-c">//</span> Runs through all the 2*R_BITS UPC counters</span>
    <span class="pl-k">for</span> (<span class="pl-c1">uint32_t</span> i = <span class="pl-c1">0</span>; i &lt; <span class="pl-c1">2</span> * R_BITS; i++) {
        <span class="pl-c1">uint8_t</span> counter = <span class="pl-c1">upc_for_index</span>(ff_upc, i);

        <span class="pl-c"><span class="pl-c">//</span> After each sequence of 32 bits is done, we have to update the next 32 flags of bits to flip.</span>
        <span class="pl-c"><span class="pl-c">//</span> Notice that, in general, not all 32 bits were consumed, and the variable current_eq_weight</span>
        <span class="pl-c"><span class="pl-c">//</span> ensures that we get the next 32 flags. Furthermore, notice that access to eq_flip_flags</span>
        <span class="pl-c"><span class="pl-c">//</span> are done in constant-time because we cannot leak current_eq_weight.</span>
        <span class="pl-k">if</span> (i % <span class="pl-c1">32</span> == <span class="pl-c1">0</span>) {
            next_32_flags = <span class="pl-c1">update_next32_flags</span>(eq_flip_flags, current_eq_weight);
            base = <span class="pl-c1">0</span>;
        }
        <span class="pl-c"><span class="pl-c">//</span> mask_gt assumes the following values:</span>
        <span class="pl-c"><span class="pl-c">//</span>      0 if the current counter is &lt;= ff_threshold.threshold</span>
        <span class="pl-c"><span class="pl-c">//</span>      1 otherwise.</span>
        <span class="pl-c1">uint32_t</span> mask_gt = <span class="pl-c1">1</span> + <span class="pl-c1">secure_l32_mask</span>(ff_threshold.<span class="pl-smi">threshold</span>, counter);
        n_found_gt_thresh += mask_gt;

        <span class="pl-c"><span class="pl-c">//</span> mask_eq assumes the following values:</span>
        <span class="pl-c"><span class="pl-c">//</span>      0 if current counter is == ff_threshold.threshold AND if</span>
        <span class="pl-c"><span class="pl-c">//</span>           n_found_eq_thresh &lt; ff_threshold.n_equal_threshold</span>
        <span class="pl-c"><span class="pl-c">//</span>      1 otherwise.</span>
        <span class="pl-c"><span class="pl-c">//</span> Therefore, it controls if the corresponding index `i` will be chosen to</span>
        <span class="pl-c"><span class="pl-c">//</span> flipped, when its counter is equal to the FixFlip threshold.</span>
        <span class="pl-c"><span class="pl-c">//</span></span>
        <span class="pl-c"><span class="pl-c">//</span> Remember that this is done because we cannot flip all bits whose counter is equal</span>
        <span class="pl-c"><span class="pl-c">//</span> to the threshold, because we risk flipping more than n_flips bits.</span>
        <span class="pl-c1">uint32_t</span> mask_eq = <span class="pl-c1">secure_cmp32</span>(counter, ff_threshold.<span class="pl-smi">threshold</span>);


        <span class="pl-c1">uint64_t</span> eq_flip_mask = <span class="pl-c1">get_randomized_eq_flip_mask</span>(next_32_flags,
                                                            &amp;base,
                                                            &amp;current_eq_weight,
                                                            mask_eq);

        n_found_eq_thresh += eq_flip_mask;
        e_decomp[i] ^= (mask_gt | eq_flip_mask);
    }
    <span class="pl-c1">assert</span>(n_found_eq_thresh == ff_threshold.<span class="pl-smi">n_equal_threshold</span>);
    <span class="pl-c1">assert</span>(n_found_gt_thresh == n_flips - ff_threshold.<span class="pl-smi">n_equal_threshold</span>);

    <span class="pl-c1">compress_e</span>(e, e_decomp);

    <span class="pl-k">return</span> ff_threshold.<span class="pl-smi">threshold</span>;
}</pre></div>
<p>Again, most of the complexity is behind another function. This time, let us expand <code>get_fixflip_threshold</code>
from the portable implementation in <code>pickyfix/pickyfix.c</code>. This is where the main part of FixFlip's
implementation occurs: the sequence of <code>COUNTING_LEVELS = 3</code> partial counting steps to find the
FixFlip threshold. For clarity, we used two auxiliary functions: <code>reduce_upcs_then_count</code> and <code>find_threshold_bucket</code>.
The first one simply reduces the UPC counters, that is, it defines what is the corresponding bucket for each UPC counter,
and then count it to the adequate bucket. The second one, <code>find_threshold_bucket</code>, is to find out which threshold bucket
should be expanded in the next step, that is, it finds out in which bucket the FixFlip threshold lives.</p>
<div class="highlight highlight-source-c"><pre><span class="pl-c"><span class="pl-c">//</span> Function:  get_fixflip_threshold</span>
<span class="pl-c"><span class="pl-c">//</span> --------------------------------</span>
<span class="pl-c"><span class="pl-c">//</span></span>
<span class="pl-c"><span class="pl-c">//</span> Finds the FixFlip threshold data used by fixflip_iter to flip a fixed number (n_flips) of bits.</span>
<span class="pl-c"><span class="pl-c">//</span> Remember that the FixFlip threshold data is defined not only by a threshold number, but by a</span>
<span class="pl-c"><span class="pl-c">//</span> pair: (tau, n_tau), which, in this implementation is represented by the type</span>
<span class="pl-c"><span class="pl-c">//</span> fixflip_threshold_t defined in fixflip.h as follows:</span>
<span class="pl-c"><span class="pl-c">//</span>      typedef struct fixflip_threshold_s {</span>
<span class="pl-c"><span class="pl-c">//</span>          uint8_t  threshold;                     // Represents threshold tau</span>
<span class="pl-c"><span class="pl-c">//</span>          uint8_t  n_equal_threshold;             // Represents n_tau</span>
<span class="pl-c"><span class="pl-c">//</span>      } fixflip_threshold_t;</span>
<span class="pl-c"><span class="pl-c">//</span></span>
<span class="pl-c"><span class="pl-c">//</span>  Function fixflip_iter then flips n_flips bits doing the following:</span>
<span class="pl-c"><span class="pl-c">//</span>      - If the bit UPC counter is greater than `threshold`: flip the bit</span>
<span class="pl-c"><span class="pl-c">//</span>      - Flip only `n_equal_threshold` bits whose UPC counter is equal `threshold`</span>
<span class="pl-c"><span class="pl-c">//</span></span>
<span class="pl-c"><span class="pl-c">//</span> Input Arguments:</span>
<span class="pl-c"><span class="pl-c">//</span>  - fixflip_upc_t *ff_upc: The UPC counter values</span>
<span class="pl-c"><span class="pl-c">//</span>  - uint32_t       n_flips: The number of bits to be flipped</span>
<span class="pl-c"><span class="pl-c">//</span></span>
<span class="pl-c"><span class="pl-c">//</span> Output Argument:</span>
<span class="pl-c"><span class="pl-c">//</span>  - fixflip_threshold_t *ff_threshold: The fixflip threshold data to be used by fixflip_iter</span>
<span class="pl-c"><span class="pl-c">//</span>                                       when deciding which bits to flip.</span>
<span class="pl-c"><span class="pl-c">//</span></span>
<span class="pl-c"><span class="pl-c">//</span>  Implementation:</span>
<span class="pl-c"><span class="pl-c">//</span>      This function performs COUNTING_LEVELS = 3 rounds of countings to find the threshold</span>
<span class="pl-c"><span class="pl-c">//</span>      values. In each level, the resolution of the counting buckets the search gets smaller. In</span>
<span class="pl-c"><span class="pl-c">//</span>      the first iteration each bucket represents a range of numbers, and by the last iteration</span>
<span class="pl-c"><span class="pl-c">//</span>      buckets represents only one number. The idea is that each iteration decides in which</span>
<span class="pl-c"><span class="pl-c">//</span>      bucket the threshold lives, and this bucket is expanded in the next iteration.</span>
<span class="pl-c"><span class="pl-c">//</span></span>
<span class="pl-k">void</span>
<span class="pl-en">get_fixflip_threshold</span>(OUT <span class="pl-c1">fixflip_threshold_t</span> *ff_threshold,
                      IN <span class="pl-c1">fixflip_upc_t</span> *ff_upc,
                      IN <span class="pl-c1">uint32_t</span>       n_flips) {

    <span class="pl-c1">uint32_t</span> base = <span class="pl-c1">0</span>;

    ff_threshold-&gt;<span class="pl-smi">threshold</span>         = <span class="pl-c1">0</span>;
    ff_threshold-&gt;<span class="pl-smi">n_equal_threshold</span> = <span class="pl-c1">0</span>;

    <span class="pl-c"><span class="pl-c">//</span> This variable counts the number of elements in buckets that are greater than</span>
    <span class="pl-c"><span class="pl-c">//</span> the current threshold_bucket</span>
    <span class="pl-c1">uint32_t</span> n_gt_threshold = <span class="pl-c1">0</span>;

    <span class="pl-c"><span class="pl-c">//</span> As described in the paper, the search for the threshold is done in COUNTING_LEVELS =</span>
    <span class="pl-c"><span class="pl-c">//</span> iterations. In each iteration, the algorithm expands the bucket of reduced counters where</span>
    <span class="pl-c"><span class="pl-c">//</span> the threshold should be in.</span>
    <span class="pl-k">for</span> (<span class="pl-k">int</span> i = <span class="pl-c1">0</span>; i &lt; COUNTING_LEVELS; i++) {

        <span class="pl-c1">uint8_t</span> counts[COUNTING_SORT_BUCKETS] = {<span class="pl-c1">0</span>};

        <span class="pl-c"><span class="pl-c">//</span> The step size resolution is increased in each iteration, which narrows down the value</span>
        <span class="pl-c"><span class="pl-c">//</span> of the fixflip threshold.</span>
        <span class="pl-c"><span class="pl-c">//</span></span>
        <span class="pl-c"><span class="pl-c">//</span> In particular, step = 8 ^ (COUNTING_LEVELS - 1 - i)</span>
        <span class="pl-c"><span class="pl-c">//</span></span>
        <span class="pl-c"><span class="pl-c">//</span> That is:</span>
        <span class="pl-c"><span class="pl-c">//</span>      - when i = 0: step = 64</span>
        <span class="pl-c"><span class="pl-c">//</span>      - when i = 1: step = 8</span>
        <span class="pl-c"><span class="pl-c">//</span>      - when i = 2: step = 1</span>

        <span class="pl-c1">uint32_t</span> step = <span class="pl-c1">1</span> &lt;&lt; (<span class="pl-c1">3</span> * (COUNTING_LEVELS - <span class="pl-c1">1</span> - i));

        <span class="pl-c"><span class="pl-c">//</span> Get the reduced counters counted into the following 8 UPC buckets</span>
        <span class="pl-c"><span class="pl-c">//</span> Bucket 0: [base, base + step[</span>
        <span class="pl-c"><span class="pl-c">//</span> Bucket 1: [base + step, base + 2*step[</span>
        <span class="pl-c"><span class="pl-c">//</span>  ...,</span>
        <span class="pl-c"><span class="pl-c">//</span> Bucket 7: [base + 7*step, base + 8*step[</span>
        <span class="pl-c1">reduce_upcs_then_count</span>(counts, ff_upc, base, step);

        <span class="pl-c"><span class="pl-c">//</span> Find out which of the 8 buckets above contains the threshold tau</span>
        <span class="pl-c1">uint8_t</span> threshold_bucket = <span class="pl-c1">0</span>;
        <span class="pl-c1">find_threshold_bucket</span>(&amp;threshold_bucket, &amp;n_gt_threshold, counts, n_flips);

        <span class="pl-c"><span class="pl-c">//</span> Move base to the start of the bucket where the threshold lives</span>
        base += threshold_bucket * step;
    }
    ff_threshold-&gt;<span class="pl-smi">threshold</span>         = base;
    ff_threshold-&gt;<span class="pl-smi">n_equal_threshold</span> = n_flips - n_gt_threshold;
}</pre></div>
<h1>
<a id="user-content-conclusion" class="anchor" href="#conclusion" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Conclusion</h1>
<p>We invite everyone interested in BIKE to experiment with our code and try to find better parameters and
decoding procedures.</p>
</article></body></html>